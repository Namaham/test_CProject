
なまはむ  12:10
学校で少しだけC言語やってると言っててけど、どの程度の事を学んでるんだろ？
　・プログラムは main から始まる事は知ってる？
　・if と for は分かるかな？
　・関数は作れるかな？
　・変数って何なのか分かるかな？

つばさ  10:11
だいたい分かるよ
10:13
iOS の画像 
iOS の画像


10:14
確かifは分岐でforはループだったかな？

なまはむ  11:43
③の答えは、 wa + kazu  ？
コンピュータでプログラムをコンパイルして実行するの？

なまはむ  12:12
https://github.com/Namaham/test_CProject

GitHubGitHub
Namaham/test_CProject
test_CProject. Contribute to Namaham/test_CProject development by creating an account on GitHub.
12:13
Visual Studio のインストールの仕方をまとめた。プロジェクトの作り方は書きかけ

つばさ  20:44
Visual Studioは既に入れてあります

なまはむ  21:01
C言語のプロジェクトを作成してコンパイル実行はできる？
例えば上の教科書のプログラムを実際に動かせるかな？

つばさ  21:02
んーちょっとやってみる

なまはむ  21:04
おっちゃん家の環境古すぎて、更新かかりまくりや＞＜；

つばさ  21:06
C言語ってC#？それともC++？

なまはむ  21:07
いま更新中で画面見れんけど、c++ コンソール 空のプロジェクトみたいなの無いかな？
21:08
ソリューション名は study
プロジェクト名は test00
こんな感じで作る

つばさ  21:08
了解です

なまはむ  21:12
これ
image.png 
image.png



つばさ  21:13
違うの開いてたかも

なまはむ  21:14
こんな感じで作成する。場所はデスクトップになんか適当なフォルダ作る
image.png 
image.png



つばさ  21:27
コンパイルってどこでするん？

なまはむ  21:30
ソースファイルは作れた？
21:31
コンパイルはここです
image.png 
image.png


21:31
ソースファイルの追加
image.png 
image.png



つばさ  21:33
それはもうできた

なまはむ  21:34
やるじゃん。
念のため。これで作れる
image.png 
image.png


21:34
んじゃ、コンパイルできた？

つばさ  21:35
一応できた
21:35
でも、実行がうまくできない

なまはむ  21:35
こんなソースでコンパイル実行できるはず
#include <stdio.h>
int main(){
 printf("test");
}
ミスってた。修正↑ （編集済み） 
21:38
実行したら、コンソール開いて、こんな結果が出るはず
image.png 
image.png


21:38
実行は
image.png 
image.png


21:39
ちなみに F5 を押せば、実行できる。
Shift + Ctrl + B でコンパイルできる。

つばさ  21:40
ファイルにウイルスまたは望ましくない可能性があるため実行出来ないって出る…

なまはむ  21:40
えぇー
21:41
なんでや…ウィルスソフトの問題か、ほんとにウィルスがおるかのどっちかやで…TT
21:41
セキュリティソフトは何か入ってるの？

つばさ  21:42
あ、新しいtest01を作ったら出来た

なまはむ  21:43
よかった…のか…？　コンパイルしたばかりのプログラムがウィルスって…

つばさ  21:43
う〜ん…わかんない

なまはむ  21:43
開いた黒いウィンドウがコンソールと言います。
この中で動くプログラムをコンソールアプリと言います。
21:44
書いたソースここに貼れる？
コピペで。

つばさ  21:44
でも、さっき警告の下にファイル場所がなんやらとも書いてあったから、保存する場所を間違えたのかも
21:45
#include<stdio.h>
int main(void)
{
    int kazu, wa;
    wa = 0;
    kazu = 3;
    while (kazu <= 99)
    {
        wa = wa + kazu;
        printf("3の倍数=%d\n", kazu);
        kazu = kazu + 3;
    }
    printf("合計＝%d\n", wa);
    return 0;
}

なまはむ  21:45
まぁ動いたんならええか(=ﾟωﾟ)ﾉ
21:46
おっちゃんも動いたイエーイ！
image.png 
image.png


21:49
#include<stdio.h>
この上に
#include<iostream>
↑
これ書き加えて
21:52
#include<iostream>
#include<stdio.h>
int main(void)
{
    int kazu, wa;
    wa = 0;
    kazu = 3;
    while (kazu <= 99)
    {
        wa = wa + kazu;
        printf("3の倍数=%d\n", kazu);
        kazu = kazu + 3;
    }
    printf("合計＝%d\n", wa);
    std::string s;
    std::cin >> s;
    printf(s.c_str());
    return 0;
}
↑このソースの下の方にある↓これも加える。コンパイル実行するとキーボードの入力待ちになる。何かうってEnterキーで入力完了。
    std::string s;
    std::cin >> s;
    printf(s.c_str());
21:53
結果はこんな感じです。
aaaaaaaaaaaaa って打って Enter 。
image.png 
image.png



つばさ  21:53
そゆことね
21:56
今、自分で打った数字の倍数を表示させようとしてるんだけど…
21:56
#include<stdio.h>
int main(void)
{
    int kazu, wa, Double;
    wa = 0;
    Double = 0;
    scanf("%d",&Double);
    kazu = Double;
    while (kazu <= 99)
    {
        wa = wa + kazu;
        printf("%dの倍数=%d\n", Double,kazu);
        kazu = kazu + 3;
    }
    printf("合計＝%d\n", wa);
    return 0;
}

なまはむ  21:56
#include <stdio.h>
これが何を意味しているか分かるかな？
stdio と言う C標準ライブラリの標準入出力のライブラリを使うという宣言です。
Standard Input Output 略して std i o = stdio です。

つばさ  21:57
それは分かる

なまはむ  21:57
scanf やね

つばさ  21:57
エラーが出るんやけどどこがおかしいか分かる？

なまはむ  21:58
みてみる。ちょっと待ってね
21:59
scanf を scanf_s にして。
22:00
エラーの英語を読めばわかるけど、安全じゃない命令だよ。 scanf_s を使ってねって書いてある。

つばさ  22:00
出来た

なまはむ  22:00
_s はセーフの s です。安全の意味。
22:00
scanf は古い命令で、セキュリティ的に使っちゃダメな命令になったのよ。

つばさ  22:01
へー初めて知った

なまはむ  22:01
コンパイラーの安全スイッチがどこかにあって、そのスイッチみたいなのを切れば scanf も使えるけど、おすすめはできないよね。

つばさ  22:02
了解(*^^*ゞ

なまはむ  22:02
ちなみに stdio.h っていうのも古いのよ。
今は <cstdio> こうだったと思う。
22:03
さらに cstdio も古くて、今は iostream です。標準入出力のライブラリはね。

つばさ  22:04
どんどん新しくなるんだね

なまはむ  22:05
ついていくのが大変なのよ。
stdio.h と cstdio は中身同じだけど、iostream はもう別物です。
ｃ言語だけでも中身がどんどん変わる。
22:06
まぁ正確には iostream は c++ なんだけどね。

つばさ  22:07
今はiostreamが主流？

なまはむ  22:08
間違いなく主流の標準入出力ライブラリです。
22:09
さっきのを関数化したよ。わかるかな？
#include<stdio.h>
void kansuu(void)
{
    int kazu, wa, Double;
    wa = 0;
    Double = 0;
    scanf_s("%d", &Double);
    kazu = Double;
    while (kazu <= 99)
    {
        wa = wa + kazu;
        printf("%dの倍数=%d\n", Double, kazu);
        kazu = kazu + 3;
    }
    printf("合計＝%d\n", wa);
}
int main(void)
{
    kansuu();
    return 0;
}

つばさ  22:11
あ、待ってわかんないかも

なまはむ  22:12
void kansuu(void)
{
　…
}
main の中にあったのを↑この中に全部入れて、 main の中から kansuu を呼んだだけ。

つばさ  22:13
了解、理解しました

なまはむ  22:13
printf と言うのも誰かが作った関数です。ライブラリとかの関数の実体は見えないとこにいるけど、元のソースは誰かがつくったものなのよ

つばさ  22:15
へぇーそうんや

なまはむ  22:16
上の関数は動かせた？

つばさ  22:16
うん、できました！
22:16
std::string s;
    std::cin >> s;
    printf(s.c_str());
22:16
いまいちこれがわかんないです…

なまはむ  22:17
#include<stdio.h>
int main(void)
{
    kansuu();
    return 0;
}
void kansuu(void)
{
    int kazu, wa, Double;
    wa = 0;
    Double = 0;
    scanf_s("%d", &Double);
    kazu = Double;
    while (kazu <= 99)
    {
        wa = wa + kazu;
        printf("%dの倍数=%d\n", Double, kazu);
        kazu = kazu + 3;
    }
    printf("合計＝%d\n", wa);
}
こうしたら動かなくなる。main の方を上に持って行った。この話はまた今度ね。
22:18
std:: これは c++ 特有の名前の修飾子みたいなものです。
22:18
std = standard = 標準
cin = Consorl Input = 標準入力 （編集済み） 
22:19
std::cin >> s;
s と言う変数に、標準入力から入力して渡す。

つばさ  22:20
んーやっぱりわかんないかも
22:21
どういう時に使うん？

なまはむ  22:21
std::string s;
s と言う string 型の変数を宣言している。
int kazu;
とかと同じです。string は文字列と言う意味です。文字列を格納する変数と言うものです

つばさ  22:22
なるほど！

なまはむ  22:22
たぶん >> これが一番意味不明なんだと思う。
= なら代入ってわかりやすいけど、なんで >> こうやねんと思うやろ。
おじちゃんも思う。
22:23
s = std::cin; こうじゃないねん。なんでやねんやねん＞＜；

つばさ  22:23
笑笑
22:24
>>は代入するってこと？

なまはむ  22:24
ちなみに
cout << s;
で
printf(s.c_str());
これやねんで。

つばさ  22:25
めっちゃ短縮できるやん

なまはむ  22:25
printf(s) じゃないのよ。printf は string 型を直接扱えないのです。
s.c_str() これで、 printf があつかえる char 型変数に置き換えてるのです。
22:26
cout = Consorl Out ね

つばさ  22:26
intとfloatみたいなこと？

なまはむ  22:27
今日はそろそろおわろ。
分からんことや質問はどんどん書いといてね。

つばさ  22:27
はーい、ありがとうございます！
22:27
じゃ、おやすみー

なまはむ  22:27
そうです。 int float double char short long いろいろあるで

つばさ  22:28
double char short　はわからん
22:28
まぁーまた今度お願いします！

なまはむ  22:28
ただし string は厳密には全然違うものなんやけど、今は変数の１つと思っておいて大丈夫。 （編集済み） 
22:28
おやすみー

なまはむ  23:26
プログラムは 1 と 0 の集合体です。
コンピュータはon/offスイッチの集まったものです。
要するにスイッチ１つで表せるのは on か off 、1 か 0 なのよ。

なまはむ  23:32
でもスイッチが２つあったら表現できる組み合わせが４つになります。
00  01  10  11  の４パターンです。
この４パターンを数値と考えると 0 1 2 3 となるわけです。

なまはむ  23:40
さて、スイッチが４つあったらどうなるかというと１６パターンです。
0000  0001  0010  0011
0100  0101  0110  0111
1000  1001  1010  1011
1100  1101  1110  1111
これを数値で表すと 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 となります。

なまはむ  23:48
プログラムでは
10 = a
11 = b
12 = c
13 = d
14 = e
15 = f
と書きます。
0 〜 f です。
これを16進数と言います。
ちなみに
0 〜 9 は10進数です。
それとプログラムでは 1 から数えるんじゃなくて、0 から数えます。

なまはむ  00:00
スイッチが８個あったら数値的にいくつ表現できるかというと 0 〜 255 までの 256 個です。
スイッチが１個なら 0 か 1 の２個
スイッチが２個なら 2 x 2 の４個
スイッチが３個なら 2 x 2 x 2 の８個
スイッチが４個なら 2 x 2 x 2 x 2 の１６個
スイッチが５個なら 2 x 2 x 2 x 2 x 2 の３２個
あとは分かるね。
スイッチが８個なら 2 を８回掛けると言うことです。

なまはむ  00:04
2 の乗数です。
2 4 8 16 32 64 128 256 512 1024 2048
4096 8192 16384 32768 65536

1 件の返信
12日前スレッドを表示する

なまはむ  00:18
プログラムで数値を使う単位の最小は８個のスイッチで表せる 0 〜 255 です。
スイッチ１つが１ビット、８個で８ビットです。
なぜそうなったのかと言うと初期のコンピュータが８個のスイッチを１塊として動作する８ビットコンピュータだったからだと思います。
現在のコンピュータは６４ビットコンピュータです。すごい進化だね。
だけど今でも数値の最小単位は８ビットのままなんだよ。

つばさ  00:34
0と1だけの2進数のやつは機械語ってやつでしょ？
00:34
2.10.16の進数の変換は学校でやった

つばさ  00:35
このスレッドに返信しました :
2 の乗数です。…
凄いわかりやすい！

なまはむ  00:43
ここでやっと int に戻ってきます。
int が変数の型だという事は知ってるね？
どう言う型かと言うと数値型です。
数値を記憶できますね。
ではいったい、いくつまでの大きさの数字が記憶できるのかと言うと
-2147483648 〜 2147483647
です。
これはね３２ビットと言うことなんだ。
int はね、正確な型名で言うと、３２ビットサイン付き整数と言う型なんだ。
サイン付きと言うのはマイナスも記憶できると言う事です。
マイナスの無い、サイン無し整数と言う型もあるよ。
unsigned int って言う型があるのよ。
表現できる範囲は 0 〜 4294967295 になる。サイン（マイナス）が無い分、プラス方向に倍の数値まで記憶できる。
00:46
お、まだ起きてるんや
暇なときに読んでくれたらええんやで〜。

なまはむ  00:51
short 型は１６ビットサイン付き整数型なんよ。-32768 〜 32767 が表現できます。
char 型は８ビットサイン付き整数型です。-128 〜 127 が表現できます。

つばさ  01:00
2147483647より大きいやつはlongを使うんだっけ？

なまはむ  01:02
大は小を兼ねるといいますが、int があれば short も char もいらんやんと思うやろ？全くその通りやで。実際 short は使わんなぁ。
でも、じゃあなんで short とかあるんや言うたらな、昔はメモリやらなんやら全てが高価な物でな、表現する幅が小さくていい場合は小さいメモリ（ビット数）ですむように使ってたんやで。
例えばテストの点を表現するには 0 〜 100 でええやろ。char 型で十分やろ。そんな時代もあったんや。今はテストの点は int 使えばええよ。 （編集済み） 
01:04
long ちゃうねん long long やねん
01:05
本当は３２ビットサイン付き整数は long の事やねん。
01:06
int は変わった子でな、コンピュータ環境に応じて表現の幅が変わる子やってん。
01:08
８ビットコンピュータでは８ビットサイン付き整数で、１６ビットコンピュータでは１６ビットサイン付き整数で３２ビットコンピュータでは３２ビットサイン付き整数やってん。
01:10
でもなコンピュータ環境が変わる度に表現の幅が変わるのは混乱するんで、ついに３２ビットサイン付き整数に固定されてん。
01:11
そろそろ寝る

つばさ  01:11
はーい、めっちゃ長文ありがとうございます
01:12
こっちもそろそろ寝ます、おやすみなさい！

なまはむ  13:28
混乱したらあかんのでまとめておくけど、
勉強中の今は、数値型の変数は int を使っておけばいいよ。

つばさ  13:50
了解です

なまはむ  23:06
int a;
a = 10;
a = a / 3;
a の値は 3 になります。
整数型を割ると余りは切り捨てられます。
分かるよね？
23:09
小数点以下も扱うなら float 型の変数を使う。
これも知ってるよね？

なまはむ  23:42
int と float があれば数値は扱えます。
次は文字列です。
文字じゃなくて文字列です。
何が違うのかというと、
a とか b とか c のように１つなら文字です。
abc とか aiueo みたいに文字が列をなしてるものを文字列と言います。
だだし説明のため１つなら文字と言いましたが、文字が１つだけ列をなしてると考える場合、１文字でも文字列です。 （編集済み） 

なまはむ  00:05
ｃ言語には文字型と言う変数は存在しますが、文字列型と言う変数は存在しません。
文字型の変数は char です。-128 〜 127 までしか記憶できないやつです。
char と言うのは character の略語です。
意味は文字です。
char 型は８ビット変数なので char 型変数１つだけではどんなに頑張っても 256 種類の文字しか表現できません。
例えば、
97 = a
98 = b
99 = c
のように考えます。
数値がどの文字を表すかは正式なコード表があります。
ASCII コードと言います。
http://www3.nit.ac.jp/~tamura/ex2/ascii.html

つばさ  06:13
ちょっと難しいかも…

なまはむ  10:48
char は難しいか…うーんと、ちょっと数値の変数について説明するね。
変数は箱って習ったと思うけど、int は数値を入れる箱です。
数値を入れたり出したり、足したり引いたりもできる。
int kazu;
kazu = 1;
kazu = 5;
kazu = 7;
1 を入れたら 1 が入ってます。
5 を入れたら 5 が入ってます。
7 を入れたら 7 が入ってます。 （編集済み） 

なまはむ  11:32
箱から取り出すと言うのは、
kazu = kazu + 3;
kazu の中に入ってる数値を取り出して 3 と足し、また kazu に入れてます。
数値を取り出してるようには見えないけど、コンピュータは箱の中から数値を取り出してるんです。
箱の中に何が入ってるのか分からないので、取り出して見てるんです。
現実と同じです。
箱の中に数字の書かれたカードが入ってて、
箱の中の数字と３を足してと言われたら、
まず最初に箱の中のカードを取り出して見ますよね。
要するに入れたものは取り出せます。 （編集済み） 

なまはむ  11:44
でも、１つの箱には１つの数値しか入れる事ができません。
２つ目の数値を入れると１つ目の数値は消えてなくなります。
現実なら１つの箱に２つでも３つでもカードを入れておけるけど、
コンピュータの世界ではできないんです。
でもね、できなくていいんです。
kazu = kazu + 3;
もし kazu の中に 1 と 5 と 7 が入ってたら、
コンピュータはどれと 3 を足せばいいのか混乱します。
プログラミングでは、そもそも１つしか入れる事ができないので、
コンピュータが混乱するような状況はあり得ないですけどね。

なまはむ  12:32
int は integer の略語です。整数と言う意味です。
char は character の略語です。文字と言う意味です。
char 型も int 型と同じように、数値を１つ入れる事ができます。
違いは入れる事ができる数値の大きさです。
 int は -2147483648 ～ 2147483647
char は        -128 ～ 127
（編集済み）
12:33
char は文字型の変数と言いましたが、実際に入れる事ができるのは数値だけです。
12:35
コンピュータは数値しか扱えません。 （編集済み） 

なまはむ  13:26
char 型変数に文字を入れるにはこのようになります。
char moji;
moji = 97;
printf("moji = %d\n", moji);     // 97 と出力されます
97 と出力されます。
printf 命令を少し修正します。%d を %c にします。
printf("moji = %c\n", moji);     // a と出力されます
a と出力されます。 （編集済み） 

なまはむ  13:41
前に説明したの覚えてるかな？
97 = a
98 = b
99 = c
 97 は a なんです。
全ての文字は数値に対応しています。
どの文字がどの数値に対応しているかは正式なコード表があります。
ASCII コードと言います。
http://www3.nit.ac.jp/~tamura/ex2/ascii.html
このコード表には a ～ z、A ～ Z、0 ～ 1、記号（$%&?+-*/…）などしかありません。
日本語の漢字やひらがなもコード表がちゃんとあります。
それについてはまた今度説明します。 （編集済み） 

なまはむ  14:04
なぜ a が出力されたのか？
printf 命令に文字で出力してとお願いしたからです。
数値を出力する場合
char moji;
moji = 97;
printf("moji = %d\n", moji);     // 97 と出力されます
printf の第一引数は、書式と言います。
"moji = %d\n" の部分です。
書式の中で %d は特別な意味があります。
第二引数の変数を %d のところに出力してね、と言う意味があります。
第二引数は moji です。
%d の d は何かと言うと、英語で decimal の事です。
１０進数と言う意味です。
moji と言う変数を１０進数で出力してね、と言う意味になります。
だから 97 と出力されました。
では文字を出力する場合ですが、
char moji;
moji = 97;
printf("moji = %c\n", moji);     // a と出力されます
 %c の c は何かと言うと、英語で character の事です。
文字と言う意味です。
moji と言う変数を文字で出力してね、と言う意味になります。
そして 97 は a です。
だから a と出力されました。
98 なら b と出力されます。
99 なら c です。 （編集済み） 

つばさ  22:00
ここまでは理解出来ました！！

なまはむ  23:17
お、やるじゃん！
char には文字を入れる事が分かったようなので、次は「文字列」です。
文字列と言うのは分かり易く言えば文章です。
"これは文章です。"
文字が複数並んで列になったものです。
つばさくんは既にプログラムで文字列（文章）を使っています。
printf("3の倍数=%d\n", kazu);
printf 命令の第一引数の "3の倍数=%d\n" の部分が文字列です。
前後の " " が無いと、コンパイルエラーになります。
printf(3の倍数=%d\n, kazu);        // これはエラーになります。
Ｃ言語プログラムの決まり事なので、
文字列は " " で囲むものだと覚えればいいのですが、
あえて理由を付けて説明します。
以下のような文章の前後に " " が無かったら、コンパイラは混乱します。
printf は、kazu を出力します。
最初に出てくる printf は命令かな？　kazu は変数かな？　…出力します。ってなんやねん？
コンパイラに分からないものは全てエラーにされてしまいます。
だから、それは文字列なんだよって、コンパイラに教えてあげる必要があります。
"printf は、kazu を出力します。"
コンパイラは、
最初に " を見つけたところを「文字列の始まり」と考え、
　次に " を見つけたところを「文字列の終わり」と考えます。
文字列はコンピュータにとって「文字列」と言う１つの値です。
１つの値なんだけど、数値と違って１つの変数の中には入り切りません。 （編集済み） 

つばさ  06:15
OK、理解しました！
06:15
説明が丁寧だから理解しやすい笑

なまはむ  11:10
よっしゃ！次や
１つの変数に入らない値をどうやって入れておくのか？
答えは変数の「配列」です。
複数の変数が列をなして連なったものです。
イメージとしては、複数の箱が直線的に繋がった感じです。
無造作に繋がってるわけじゃなくて、直線的にです。
こんな感じでです。
□□□□□□□□□□□□□□□□…
そして隣り合う箱同士は切り離す事はできません。
なんとなくイメージできたかな？

なまはむ  12:37
変数の配列と説明してきましたが、分かり難いので、
以後は「配列変数」もしくは単に「配列」と言います。
配列の宣言 と 使い方
char mojiretu[4];        // [4] = ４つの箱が連なった配列
mojiretu[0] = 97;
mojiretu[1] = 98;
mojiretu[2] = 99;
mojiretu[3] = 0;
《配列の宣言》
普通の変数宣言のように記述し、後ろにいくつ箱が連なってるのかを記述します。
上記の例の場合、[4] なので、４つの箱が連なった配列です。
前後の [ ] はＣ言語の記述ルールです。覚えちゃってください。
《使い方》
１つ目の箱に数値を入れるなら、変数名の後ろに [0] を付けます。
１つ目なのになぜ 0 なのかと言うと、プログラムにとっての１つ目は 0 だからです。
単純に覚えて下さいと言うか、慣れて下さい。
いろいろなプログラム言語がありますが、配列の１つ目は 0 です。
ついでなので、日本語的プログラム用語を紹介します。
覚えなくてもそのうち慣れるよ。
・箱が４つある配列を宣言しましたが、これを４つ「確保する」と言います。
・配列の何番目かを使う際に付ける数字の事を「配列番号」とか「要素番号」とか「添え字」などと言います。
char 型の配列を１０個確保して、３番目に 100 を入れてと言われたら…
char aaa[10];        // 10個確保
aaa[2] = 100;
// もしくは
aaa[3] = 100;
３番目と言われた場合、配列の３つ目なのか、配列番号の３なのか分かりません。
会話の流れや、その人の言い方の癖によるので、ほんとに分かりません。
ちなみにプログラマは０番目とか普通に言います。

なまはむ  15:14
文字列の話に戻りたいけど、もう少しだけ配列のお話です。
char mojiretu[4];        // [4] = 確保した配列数は４
mojiretu[0] = 97;
mojiretu[1] = 98;
mojiretu[2] = 99;
mojiretu[3] = 0;
mojiretu[4] = 123;       // 実行するとここでエラーが発生します。
[0] ～ [3] への代入はちゃんと動きます。
しかし [4] に代入するとプログラムはエラー（例外発生）で落ちます。
なぜなのか？
[4] は５番目の要素です。
確保した配列数は４です。
確保していない（存在しない）変数を使ってしまったのでエラーです。
慣れるまでよく間違うのですが、
配列を n 個確保したら、使っていいのは [n - 1] までです。
n が 10 なら [10 - 1] = [9] までです。
※数学的な説明では、値の決まってない数を表現するのに n の１文字をよく使います。
　たぶん、number の n ですね。

なまはむ  15:31
さらに話はそれますが、エラーには大きく２種類あります。
「コンパイル時エラー」と「実行時エラー」です。
《コンパイル時エラーとは》
コンパイル中に、コンパイラが教えてくれる「スペルミス（誤字）」や、「構文ミス（プログラムの書き方の間違い）」です。
《実行時エラーとは》
プログラムの実行中に起こる動作不能のエラーです。
配列の確保数を超えて使ってしまう事をアクセスエラーと言います。
エラーなのにコンパイラは教えてくれません。
コンパイラが教えてくれるのは「スペルミス（誤字）」や、「構文ミス（プログラムの書き方の間違い）」だけです。
しかし Visual Studio はとても賢いです。
コンパイルの結果としては教えてくれませんが、
プログラムを書いてる最中や、コンパイル時にプログラムを解析して教えてくれます。
本当の意味でのコンパイルエラーではありませんが、エラーはエラーなので修正すればいいのです。 （編集済み） 
image.png 
image.png



なまはむ  15:44
以下のソースはコンパイルエラーじゃないので、
コンパイルは成功して、実行もできます。
ただし実行するとエラー（例外）が発生します。
int main() {
	char mojiretu[4];        // [4] = ４つの箱が連なった配列
	mojiretu[0] = 97;
	mojiretu[1] = 98;
	mojiretu[2] = 99;
	mojiretu[3] = 0;
	mojiretu[4] = 123;       // ここでエラー（例外）が発生します。
	return (0);
}
（編集済み）
15:47
Visual Studio で F5 を押せばコンパイル→実行できるけど、
エラーが出た後は、Shift + F5 で実行を止めて下さい。（Shift キーを押しながら F5 を押す）
15:50
それか、以下のメニューから「デバッグの停止」を選択する
image.png 
image.png



つばさ  21:05
ちょい今日は疲れたから明日は1日暇やから明日ゆっくり読みます笑

なまはむ  21:20
お疲れさま。暇なときにやればええんやで。おぢちゃんは勝手に書くから。

なまはむ  22:12
数値を入力して、出力する。
int aaa;                   // int 型変数を宣言
scanf_s("%d", &aaa);       // 数値を入力
printf("%d\n", aaa);       // 出力
%d の d は decimal の略語で、１０進数を意味します。
文字列を入力して、出力する。
char sss[10];              // 確保数１０個の char 型配列変数を宣言
scanf_s("%s", sss, 10);    // 文字列を入力
printf("%s\n", sss);       // 出力
%s の s は string の略語で、文字列を意味します。
scanf_s の第三引数が 10 になってます。
この値は配列の確保数以下にしなくてはなりません。
最大１０文字までしか受け取れない事を scanf_s に教えてあげます。
間違って 11 を指定した場合は、１１文字以上を入力すると実行時エラーになります。
（※正確には、下記の null 文字分があるので１０文字以上を入力するとエラーになります。）
実際に受け取れる文字数は、指定した文字数より１文字少なくなります。
上記の例の場合、実際に受け取れるのは最大９文字までです。
理由は最後に文字列の終了を意味する null コードがあるからです。
実際の null コードはこんな感じです。
char sss[10];
sss[0] = 97;          // 97 = a
sss[1] = 98;          // 97 = b
sss[2] = 99;          // 97 = c
sss[3] = 0;           // 0 = null コード。これが無いと実行時エラーになります。
printf("%s\n", sss);  // abc と出力されます。
このコードはこんな書き方もできる
char sss[10];
sss[0] = 'a';         // 97 = a
sss[1] = 'b';         // 97 = b
sss[2] = 'c';         // 97 = c
sss[3] = '\0';        // 0 = null コード。これが無いと実行時エラーになります。
printf("%s\n", sss);  // abc と出力されます。
なぜ null コードが必要なのかと言うと、printf に文字列の最後を教えてあげるためです。
printf などの文字列を扱う命令は null を文字列の最後と考えて動作します。
もし null が無かったら、実行時エラーになります。 （編集済み） 

なまはむ  10:40
ちょっと休憩…
scanf や printf だけでもまだまだあるんだけど、
プログラムの本質じゃないのであまり深くは掘り下げません。
scanf や printf なんて久々に使ったよ。
つばさくんに教えるために改めて調べたよ。
知らなかった事の方が多かったよ。
printf は覚えてたけど、scanf なんて名前すら完全に忘れてた…（滝汗
それくらいライブラリ関数を覚える事はどーでもいい事なんです。（←★言いたいのはこれ）
グーグル先生に訊けば、だいたい分かる。
ましてや関数名の綴り（スペル）を一生懸命覚えるなんてナンセンスです。
コピペでえーねん。とは言え学校のテストために覚えさせられそう…
覚えなきゃいけないのは、Ｃ言語の使い方（ルール、決まり事）です。
●ビットってなんや？
　0 と 1 です。
●変数ってなんや？
　宣言の仕方。
　型やサイズ（ビット数、入れる事の出来る大きさ）がある。
　使い方：代入、演算（足す引く割る掛けなど）、関数の引数にできる
●配列ってなんや？
　宣言の仕方。
　変数が連続して並んだもの。
●その他の専門用語
　コンパイルする（ビルドする）、実行する、コンソールに出力する、などなど。
　覚えると言うよりプログラムの会話をしてれば自然に身に付くよ。
もう一度言うけど、関数（命令）の名前や使い方を覚えるのはどーでも良くて、
こんな命令あったなぁ…とか、こんな命令ないかぁ…とかでグーグル先生に訊けば良いのよ。
例えば「Ｃ言語、コンソールに出力」で調べたら間違いなく printf が検索されます。
今はまだ何をどうやって調べたらいいのか分からないかもしれないけど、
知識が増えてきたら検索できるようになるよ。
（続く…） （編集済み） 

なまはむ  12:43
関数を深堀しても仕方ないと言う事を scanf_s で説明しますね。
scanf_s が実行されると、キーボード入力が開始されます。
char sss[10];              // 確保数１０個の char 型配列変数を宣言
scanf_s("%s", sss, 10);    // 文字列を入力
printf("%s\n", sss);       // 出力
キーボードで以下のように入力すると、printf が abc と出力してくれます。
abc Enter                  ←abc と Enter の間にスペースは入れません。abc に続けて Enter を押して下さい。
abc
では、もう一度プログラムを実行して、キーボードで以下のように入力すると、
abcdefghij Enter           ←１０文字入力した
配列数は [10] なので、null コードを考えると最大で９文字まで入力できるはずです。
しかし結果は、何も入力されません。
理由は scanf_s の仕様（処理の仕方として定められた動き）のためです。
指定された文字数を超えた場合は何も返えさ無いと言う仕様があります。
次は２回続けて、scanf_s → printf を実行します。
char sss[10];              // 確保数１０個の char 型配列変数を宣言
scanf_s("%s", sss, 10);    // 文字列を入力
printf("%s\n", sss);       // 出力
scanf_s("%s", sss, 10);    // 文字列を入力
printf("%s\n", sss);       // 出力
キーボードで以下のように入力すると、
abc def Enter         ←abc と def の間にはスペースを入れて下さい。def Enter の間にはスペースはいらないです。
scanf_s が２回あるんだからキーボード入力も２回あるはずと思うかもしれませんが、
Enter を押すと以下のように出力されて、２回目のキーボード入力はありません。
abc def Enter         ←１回目の scanf_s
abc                   ←１回目の printf
def                   ←２回目の printf
これも理由は scanf_s の仕様です。
abc の後にあるスペースを入力の区切りと考えてそこまでの文字を１回目に返します。
次の scanf_s は続きの入力（まだ残ってる文字）である def を受け取ります。
この問題（？）にはそれぞれ解決策はあります。
scanf_s の %s を %9s にする事で、入力が多すぎた場合でも必ず９文字までは返してくれます。
char sss[10];              // 確保数１０個の char 型配列変数を宣言
scanf_s("%9s", sss, 10);   // 文字列を入力（★ %s を %9s にしました）
printf("%s\n", sss);       // 出力
rewind(stdin); と言う命令で残っている入力をクリア（削除）します。
char sss[10];              // 確保数１０個の char 型配列変数を宣言
scanf_s("%s", sss, 10);    // 文字列を入力
printf("%s\n", sss);       // 出力
rewind(stdin);             // ★残っている入力をクリア（削除）する
scanf_s("%s", sss, 10);    // 文字列を入力
printf("%s\n", sss);       // 出力
関数（命令）には必ずマニュアル（仕様書）があります。
関数の使い方を覚えると言うより、マニュアルを見て使うが正しい姿勢です。
何度も使ってる関数はさすがに覚えます。
それと scanf_s や printf は書式と言うものや、可変引数と言うものがあります。
使いこなせれば便利な関数（いろんな事ができる関数）なのですが、
それゆえにとても使い方が難しい関数です。
難易度としては、初心者が使うような関数じゃないけど、
コンソールプログラムを学ぶのに便利だから使われてるように思います。（おぢさんの勝手な考えです）
書式を使いこなせば、文字に色を付けたり、任意の箇所に文字を出力したりもできるよ！＼(^o^)／
だけど覚えるんじゃなくて、マニュアル見て使えば良いのです。
https://dev.grapecity.co.jp/support/powernews/column/clang/047/page02.htm
要するに覚えるんじゃなくて、使う時にマニュアル見ればいいよと言う事です。 （編集済み） 

つばさ  20:41
んーだんだん難しくなってきた…6割くらいは理解出来るかなってレベル

なまはむ  20:43
わからんまんま進んでもいいし、質問して分かってから進むもよしです。
最初は何をどう聞けばいいのかもわからないかもしれない…
20:45
サンプルで張り付けてるソースは、なるべくコピペしてコンパイル実行はした方が良いです。
コンパイラの使い方やキーボードに慣れるから。

つばさ  20:56
了解！

kazuhito yoshidaya  21:41
今度、vstudio入れて追っかけます。おやすみ

なまはむ  21:42
追いついて下さい。新しいレジアプリとか作れるように頑張りましょう＼( 'ω')／

なまはむ  11:44
次に教える事を一言で説明すると「ポインターはメモリの番地を指します」です。
int aaa;                   // int 型変数を宣言
scanf_s("%d", &aaa);       // 数値を入力
printf("%d\n", aaa);       // 出力
char sss[10];              // 確保数１０個の char 型配列変数を宣言
scanf_s("%s", sss, 10);    // 文字列を入力
printf("%s\n", sss);       // 出力
scanf_s に注目して下さい。
scanf_s("%d", &aaa);       // 数値を入力
scanf_s("%s", sss, 10);    // 文字列を入力
aaa と sss 変数の記述が少し違いますよね？
& が付いてるか、付いていないかです。
これは scanf_s に『値』じゃなくて『ポインター』を渡してるんです。
変数に & を付けると『ポインター』になるんです。
たぶん意味が分からないと思うので、詳しく説明します。 （編集済み） 

なまはむ  12:06
値の最小単位は８ビットです。
なぜ８ビットなのかと言われると、たぶんちょうどよかったからです。
ビット数が多すぎても無駄だし、少なすぎると足りないし、そんな理由です。（違うかもしれないけどそう考えてね）
コンピュータは ８ビット 単位で考えます。
プログラムでは８ビットの事を『１バイト』と言います。
コンピュータは １バイト 単位で考えます。
実は変数の箱の大きさは『１バイト』なんです。
char 型は 　８ビット だから １バイト 変数です。　（　８ ÷ ８ ＝ １）
 int 型は ３２ビット だから ４バイト 変数です。　（３２ ÷ ８ ＝ ４）
と言う事は int 型は箱が４つ並んでるんです。
まるで配列のようですね。 （編集済み） 

なまはむ  12:22
コンピュータは ＣＰＵ と メモリ で動いています。
ＣＰＵは考えるやつです。
メモリはデータが置いてあるところです。
ＣＰＵはメモリに置いてあるデータを取り出して考えます。

なまはむ  13:06
メモリとは何か？
メモリは１バイトの『箱』が一直線に並んだものです。
どんだけ並んでいるかと言うと最大で 18446744073709551616 個です。
メモリの最初は 0 番地、メモリの最後は 18446744073709551615 番地です。
値を入れるならこんなイメージです。（実際にはこんなプログラムの書き方は無いよ）
Memory[0] = 0;
Memory[1] = 0;
Memory[2] = 0;
…
Memory[100] = 0;
Memory[101] = 0;
…
Memory[9999] = 0;
…
Memory[18446744073709551615] = 0;
まるで配列のようですね。 （編集済み） 

なまはむ  13:27
データとは何か？
0 と 1 のビットで表す事ができるあらゆるものがデータです。
値（数値、文字、文字列）、画像、音楽、アプリケーション、…
アプリケーションも 0 と 1 の集合体なのでデータです。（実際にはアプリケーションをデータと言う人はいないのでご注意下さい）
人間と言うものを 0 と 1 で表す事ができたなら、人間もデータです。
この世はもしかしたらコンピュータシミュレーションかもしれないと本気で考えてる人だっています。
マトリックスって映画知ってるかな？ （編集済み） 


2 件の返信
最終返信: 5日前スレッドを表示する

なまはむ  13:43
変数は箱です。
メモリも箱です。
どちらも値（データ）を入れておく箱です。
もしかしなくてもその通りです。
変数はメモリです！＼( 'ω')／
char 型は箱１つ分です。
メモリ上の 0 ～ 18446744073709551615 番地のどこかにある箱１つ分です。
プログラムで char moji; と宣言したら、メモリ上のどこかにある番地の箱を１つもらえます。
どこかを知りたかったら &moji です。（やっと & が出てきたぞ＼( 'ω')／）
&moji とすると、番地が取得できます。
こんなイメージです。（実際にはこんなプログラムの書き方は無いよ）
BANTI = &moji;            // moji の番地を取得して BANTI に代入する。
Memory[BANTI] = 0;        // BANTI 番地にある箱に 0 を入れる。
これは、こう言う事です。
moji = 0;                 // moji と言う箱に 0 を入れる。
（続く…） （編集済み） 

なまはむ  18:26
番地を指す変数の事をポインターと言います。
moji と言う変数の番地の番号を取得して、BANTI と言うポインターに代入しています。
BANTI = &moji;            // moji の番地を取得して BANTI に代入する。
これを実際のプログラムで書くとこのようになります。（これはイメージじゃなくて、ちゃんと動きます）
char moji;                // 普通の変数宣言
char *BANTI;              // ポインターの変数宣言
BANTI = &moji;            // moji の番地を取得して BANTI に代入する。
ポインターも変数です。変数宣言してから使います。
これは char ポインター と言う名前の変数型です。
char *
char 変数の型の後ろに * が付いてるだけです。
moji と言う変数の番地の番号を取得して、BANTI と言うポインターに代入しています。
BANTI = &moji;            // moji の番地を取得して BANTI に代入する。
BANTI には 100 が入るかもしれませんし、31642589 が入るかもしれません。
何番地が取得されるかはわかりません。
moji の番地は、それが変数宣言した時に、コンピュータが勝手に決めます。（プログラマは指定できません）
ただし一度決められた番地はその変数が消えるまで変わりません。 （編集済み） 

なまはむ  18:56
ポインターが指す番地に値を代入する。
イメージではこんな感じ（実際にはこんなプログラムの書き方は無いよ）
Memory[BANTI] = 0;        // BANTI 番地にある箱に 0 を入れる。
これを実際のプログラムで書くとこのようになります。（これはイメージじゃなくて、ちゃんと動きます）
char moji;                // 普通の変数宣言
char *BANTI;              // ポインターの変数宣言
BANTI = &moji;            // moji の番地を取得して BANTI に代入する。
*BANTI = 0;               // Memory[BANTI] = 0;
↑ これと、↓ これが同じ箱に値を代入してると言っても難しいですよね？
moji = 0;                 // moji と言う箱に 0 を入れる。
↑ これをイメージで表すと、↓ このようになります。
Memory[&moji] = 0;        // moji のある番地の箱に 0 を入れる。
コンパイラは このようにプログラムを変換しています。
コンピュータが処理できるのは数値だけなので、変数の番地に変換しています。
人間は名前の付いてる変数（例えば moji や kazu）だからプログラミングしやすいですが、
もし番地でプログラムしろって言われたら超絶難しいです。
しかしコンピュータは数値しか処理できないので番地じゃないと困ります。
だからコンパイラが変換してるんです。 （編集済み） 

なまはむ  19:19
配列もポインタもなんとなくしか理解できていないと思います。
今はそれで良いです。
次からは実践的にプログラミングしていきます。

なまはむ  19:38
関数を作ってみよう
#include <stdio.h>
void test()
{
	printf("Hello Function!");
}
int main()
{
	test();
	return 0;
}
結果
Hello Function!
void test() と言う関数を作りました。
void は返り値は無しを意味します。（返り値が無しとは？　後で説明します）
test は関数の名前です。（★自由です）
() は引数を記述するところですが、これは引数無しを意味します。（引数無しとは？　後で説明します）
{ は関数の処理の始まりで、} は関数の処理の終わりです。
処理は printf で "Hello Function!" を出力しています。（Function は関数と言う意味です。こんにちは関数！） （編集済み） 
19:43
関数の使い方。
test();
このように関数の名前で使います。
 () は引数を記述するところですが、これは引数無しを意味します。（引数無しとは？　後で説明します） （編集済み） 
19:44
★問題：
test と言う関数の名前を変えて下さい。
関数の名前を変えて動けばクリアです！＼( 'ω')／ （編集済み） 

なまはむ  20:03
引数の有る関数を作ってみよう
#include <stdio.h>
void add_print(int a, int b)
{
	printf("%d + %d = %d\n", a, b, a + b);
}
int main()
{
	add_print(3, 5);
	return 0;
}
結果
3 + 5 = 8
void add_print(int a, int b) と言う関数を作りました。
void は返り値は無しを意味します。（返り値が無しとは？　後で説明します）
add_print は関数の名前です。（自由です）
(int a, int b) は int a と int b と言う２つの引数を持っていると言う事を意味します。
引数の書き方は、変数宣言と同じです。
変数型と変数名です。
int a    // a が変数名
int b    // b が変数名
この関数の例では、２つの引数を持っているのでカンマ（ , ）で区切って２つを並べています。
(int a, int b)
関数の使い方。
add_print(3, 5);
この関数は引数が２つ必要なので、それぞれの引数に値を代入してやります。
int a には 3 が入ります。
int b には 5 が入ります。
ちなみに値を引数に代入する事は、値を引数に渡すと言います。
また、引数の立場からすると値を受け取ると言います。
関数の中の printf がなんかややこしいですね
printf("%d + %d = %d\n", a, b, a + b);
書式は
"%d + %d = %d\n"
%d が３つあるので、それぞれのところに１０進数で値を出力します。
, a, b, a + b
a と b と a + b の３つです。
a + b って渡せるの？と思うかもしれませんが、
・a は a の変数に入ってる値を取り出して printf に渡しています。（引数１）
・b は b の変数に入ってる値を取り出して printf に渡しています。（引数２）
・a + b は a と b のそれぞれの変数に入ってる値を取り出して、足した値を printf に渡しています。（引数３）
★問題：
add_print(3, 5);
ここを書き換えて、27 + 73 = 100 と出力してみて下さい。
出力できたらクリアです！＼( 'ω')／ （編集済み） （編集済み） 

なまはむ  20:48
返り値のある関数を作ってみよう
#include <stdio.h>
int add_return(int a, int b)
{
	return a + b;
}
int main()
{
	int a = add_return(27, 73);
	printf("%d\n", a);
	return 0;
}
結果
100
int add_return(int a, int b) と言う関数を作りました。
最初の int は int 型の返り値がある事を意味します。（返り値が無し void は英語で『空』と言う意味です）
add_return は関数の名前です。（自由です）
(int a, int b) は int a と int b と言う２つの引数を持っていると言う事を意味します。
返り値のある関数には、その関数が返す変数の型を最初に書きます。
int 型を返すなら int 、char 型を返すなら char と記述します。
関数の使い方。
int a = add_return(27, 73);
関数の返り値は、その関数が返す変数の型で受け取ります。
例では int 型の a と言う変数で受け取ってます。
★ワンポイント：
Ｃ言語の関数の返り値は１つしかありません！
複数は無いんです。

なまはむ  21:40
ポインターで返り値を受け取れる関数を作ってみよう
#include <stdio.h>
void add_return_2(int a, int b, int* p)
{
	*p = a + b;
}
int main()
{
	int c;
	add_return_2(27, 73, &c);
	printf("%d\n", c);
	return 0;
}
結果
100
void add_return_2(int a, int b, int* p) と言う関数を作りました。
void は返り値は無しを意味します。
add_return_2 は関数の名前です。（自由です）
(int a, int b, int* p) は int a と int b int* p と言う３つの引数を持っていると言う事を意味します。
注目は３つ目の引数 int* p（int 型ポインター p）です。
ポインターは変数の番地です（＝ 箱の番地です ＝ メモリの番地です）
その番地が指すところに値を入れれば、その番地にある変数に値を入れた事になります。
使い方
int c;
add_return_2(27, 73, &c);
３番目の引数 c に & が付いています。
& を付けると言う事は、その変数の番地を取得すると言う事です。
なので取得した番地を３番目の引数として関数に渡しています。
関数の処理
void add_return_2(int a, int b, int* p)
{
	*p = a + b;
}
３番目の引数 p には渡された変数 c の番地が入っています。
ポインター変数の頭に * を付けて使うと言う事は…
*p =
イメージ的にはこのように考えます。
Memory[p] =
p は変数 c の番地なので、イメージ的はこのように考えます。
Memory[&c] =
このイメージを元に戻すと、
c =
c に値を代入したことになります。
回りくどく説明していますが、
ポインターが指す番地に値を入れたと言うだけの事なんです。
★ワンポイント：
これがポインターの基本の使い方です。
ポインター引数を１０個持つ関数を作れば、１０個の返り値を受け取る事ができます。

なまはむ  21:57
ここにたどり着くのはいつになるかな…？
たどり着いたらポインターについてどのくらい理解できたか教えてほしいです。

つばさ  22:03
まだ、全然読み切れてない…

なまはむ  22:22
のんびりでええんやで。
良く理解できなくても、どんどん先に読み進めた方が良いと思う。
同じ事を何度も説明してるつもりだからそのうち理解できるかも。
たぶん… _(:3 」∠)_

つばさ  15:51
だいたい理解しました(￣^￣ゞ

つばさ  18:27
このスレッドに返信しました :
データとは何か？…
マトリックスは知らないけど、仮想現実説みたいなやつでしょ？
新しい返信を確認する

なまはむ  18:33
全部読んだの？ 早い！

つばさ  18:34
所々理解できなかった所があったけど、とりあえず目は通しました
18:35
ただ実行はまだ何もしてないかな

なまはむ  09:17
次からは実践あるのみ。
教えるのが難しいのはポインターだけやねん。
覚えることはほとんどないと言ったら変だけど、プログラミングは慣れるもんやねん。ｃ言語の構文や Visual studio の使い方はこれからどんどん教えていくけど、１度使えばなんとなく分かって、２度使うと理解が進んで、３回使えば覚える、そんな感じ。忘れても検索したらすぐ見つかる。

つばさ  11:18
時間のある時にしてみる！

なまはむ  11:12
永久にループさせる
#include <stdio.h>
int main()
{
	while (1) {
		printf("w");   // w をコンソールに出力
	}
	return 0;
}
結果
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww…
while はプログラムをループさせるための制御文です。
while (条件) {
	// 処理
}
( ) の中の条件が成立するなら、{ } の中の処理を実行します。
{ } の中の処理が実行されると、再び条件を判定します。条件が成立するなら、また { } の中の処理が実行し、再び条件を判定します。条件が成立するなら…
と言う処理を条件が成立する限り永久に繰り返します。
条件が 0 じゃなければ成立します。
-1 でもいいし、1 でもいいし、2548 でもいいです。
要するに 0 じゃなければ成立します。
なので while 文の条件が 1 なら、永久にループします。
while (1) {
	// 処理
}
プログラムにおいて、
条件が成立する　事を「真」と言います。
条件が成立しない事を「偽」と言います。
プログラムにおいて条件処理は必須ですが、今は深く考えずに先に進みます。
今回みてほしいのは、永久にループするプログラムの実行です。
このプログラムを実行すると永久に止まりません。（終わりません）
ウィンドウの右上の×を押して終了して下さい。 （編集済み） 

つばさ  19:05
理解しました！

なまはむ  19:40
キー入力に反応して文字を出力する
#include <stdio.h>
#include <conio.h>
int main()
{
	while (1) {
		if (_kbhit()) {
			int c = _getch();
			printf("%c", c);
		}
	}
	return 0;
}
結果
キーボードのキーを押すたびに押したキーの文字が表示されます。
_kbhit() と _getch() を使うために必要なヘッダファイルのインクルード
#include <conio.h>
.h はヘッダファイルと言います。
Ｃ言語のソースファイルは .c ですね。
ヘッダファイルについてはもっと後で説明します。
今回は、_kbhit() と _getch() を使うために必要なものだと思ってください。
このヘッダファイルのインクルードが無かったら、コンパイルエラーになります。
_kbhit() はキーボードが押されたら 1 を返す関数です。
if (_kbhit()) {
}
これじゃ分かり難いと思うので、少し分かり易くします。
int result = _kbhit();
if (result == 1) {
}
_kbhit() からの返り値を result 変数で受け取り、if で判定しています。
キーボードが押されたら _kbhit() は 1 を返します。押されてないなら 0 を返します。
if の中の条件式は result が 1 と等しいならと言う意味です。
Ｃ言語で等しいと言う意味は == と言う式です。
= が１つだと代入を意味するので全く違う意味になるので注意して下さい。
if 文
if (条件) {
}
if の条件が真なら { } の中の処理を実行します。
while 文の条件と同じです。（while のように繰り返しはしませんよ。）
if の条件式をこのようにすると、0 と等しくないならと言う意味になります。
int result = _kbhit();
if (result) {             // 0 と等しくないならと言う意味
}
_kbhit() が返す値は 0 か 1 なので、0 と等しくないならと判定しても動きます。
ちなみに 0 と等しくないならと言うのを明示的に記述するなら、以下のように書きます。
if (result != 0) {
}
!= は等しくないと言う意味です。
関数の返り値をいちいち変数に入れてから条件判定をする必要はありません。
if (_kbhit()) {            // if (_kbhit() == 1) {   でも良いし、  if (_kbhit() != 0) {   でも良い。
}
_getch() は押されたキーを取得する関数です。押されたキーの文字コードを返します。
int c = _getch();
printf("%c", c);
int c と言う変数で文字コードを受け取っています。
次の行で printf でコンソールに出力しています。
このプログラムも止まらないので、ウィンドウの右上の × を押して終了して下さい。 （編集済み） 

なまはむ  21:36
文字を出力する場所を指定する
#include <stdio.h>
#include <conio.h>
int main()
{
	while (1) {
		if (_kbhit()) {
			int c = _getch();
			printf("\x1b[3;7H");       // 追加
			printf("%c", c);
		}
	}
	return 0;
}
結果
画面の上から３行目、横に７桁目に文字を出力します。
前のプログラムに１行追加しました。
printf("\x1b[3;7H");
これで文字の出力位置を指定できます。
以下の文字列は呪文です。
"\x1b[3;7H"
コンソールプログラムにはこのような呪文で画面を制御する機能が備わっています。
この呪文の中で、3 と 7 の文字以外は、マニュアルを見てそのまま書きました。
3 と 7 は、出力位置です。この値を変えると出力位置が変わります。
他にも呪文はあります。例えば、画面をクリアする呪文です。
"\x1b[2J"
この呪文は覚えるものじゃないです。マニュアルを検索で見つけてそのまま使うようなものです。
このプログラムも止まらないので、ウィンドウの右上の × を押して終了して下さい。 （編集済み） 

つばさ  06:11
理解しました(￣^￣ゞ

なまはむ  16:00
繰り返し処理（回数処理）
#include <stdio.h>
#include <conio.h>
int main()
{
	while (1) {
		if (_kbhit()) {
			int c = _getch();
			for (int i = 0; i < 5; i++) {
				printf("%c", c);
			}
		}
	}
	return 0;
}
結果
キーボードを押すと５文字ずつ出力
for 文は繰り返したい回数がわかってる場合に使うループ制御文です。
for (int i = 0; i < 5; i++) {
	// （処理）
}
( ) の中は以下のように目的の決まった式です。
for (★初期化式; ★条件式; ★後始末の式) {
	// （処理）
}
分かり易くするため while で書いてみます。
int i = 0;          // ★初期化式
while (i < 5) {     // ★条件式
	// （処理）
	i++;            // ★後始末の式
}
なんだか余計に分かり難くなった感がありますが、冷静に解析していくと分かります。
・まず初めに i に 0 を代入します。（★初期化式）
・次の行から while が始まっています。
・条件式が成立しているならループする。 i の値が５より小さいならループする。（★条件式）
・ループ内の最後で i の値を 1 進めて（足して）います。（★後始末の式）
《★初期化式》
ループを制御するために使っている変数を初期化する式です。
このサンプルでは i と言う変数を使っています。
《★条件式》
while の条件のところに式を書くのは初めてですが、
要は条件が成立しているならループします。
i < 5 とは、i の値が５より小さいならループします。
for も while と同様に条件が成立しているならループします。
なので i < 5 は、i の値が 5 より小さいならループします。
i の値は 0 から始まって 1 ずつ加算されています。
i の値が 0, 1, 2, 3, 4 の時にループするので、５回ループします。
i の値が 5 になると i < 5 の条件が成立しないのでループを抜けます。
《★後始末の式》
後始末とは、ループする前に行う処理の事です。
for がループする直前に行う処理です。
i++; は i = i + 1; が簡略化された式です。i に 1 を加算する式です。
i++; はインクリメントと呼ばれ、変数に　 1 を加算します。ちなみに
i--; は　デクリメントと呼ばれ、変数から 1 を減算します。
for 文の i++ を i = i + 1 に書き換えても問題なく動きます。
ついでなので、変数に値を足したり引いたり掛けたり割ったりする場合は以下のように記述するのが普通です。
i++;      // i = i + 1;  インクリメント（１加算代入式）
i--;      // i = i - 1;  　デクリメント（１減算代入式）
i += 3;   // i = i + 3;  加算代入式
i -= 5;   // i = i - 5;  減算代入式
i *= 7;   // i = i * 7;  乗算代入式
i /= 9;   // i = i / 9;  除算代入式
for でも無限ループはできる！（条件式が無いと永久にループします）
for (;;) {
	// （処理）
}
こんな変則的な書き方でも動く
int i = 0;
for (; i < 5;) {
	// （処理）
	i++;
}
繰り返し処理では for と while のどちらを使えば良いのか？
使いたい方を使えば良いです。
ただし、このサンプルの for のように、５回繰り返したいと明確な場合は for を使うのが普通だと思います。 （編集済み） 

なまはむ  19:50
乱数
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
int main()
{
	while (1) {
		if (_kbhit()) {
			int c = _getch();
			int x = rand() % 10 + 1;
			printf("\x1b[3;%dH%c", x, c);
		}
	}
	return 0;
}
結果
キーボードを押すと３行目の１～１０桁の位置に文字を出力
乱数とは、サイコロを振った時のように、1 ～ 6 のいずれの目が出るか分からないような「ランダム」な値の事です。
《余談》
ランダムってわかる？何が出るか分からないみたいな感じです。
単語の説明のためにさらに単語の説明すると意味わからなくなりますね…ランダムくらいわかると信じてます。
乱数命令の rand を使うためにインクルードする
#include <stdlib.h>
rand の使い方
int x = rand() % 10 + 1;
x には 1 ～ 10 のいずれかの値が代入されます。
rand() はサイコロと違って 0 ～ 4294967295 のいずれかの値を返します。
上記の式を分解します。
int x = rand() % 10 + 1;
↓
int a = rand();      // a には rand() の返り値である 0 ～ 4294967295 のいずれかの値が代入されます。
int x = a % 10;      // % は剰余演算子です。「剰余」とは割った余りの事です。
x += 1;              // x に 1 を加算しています。
rand() の返り値を a に代入している事は分かると思います。
a には 0 ～ 4294967295 のいずれかの値が代入されます。
次の a % 10 が見慣れない式ですね。
この % と言う演算子はプログラム特有の演算子で、割った時の余りを算出するための演算子です。
剰余算と言います。
正の数ならどんな値でも 10 で割った時の余りは 0 ～ 9 のいずれかになります。
  0 % 10 = 0
  1 % 10 = 1
  2 % 10 = 2
  3 % 10 = 3
  4 % 10 = 4
  5 % 10 = 5
  6 % 10 = 6
  7 % 10 = 7
  8 % 10 = 8
  9 % 10 = 9
 10 % 10 = 0
 11 % 10 = 1
 12 % 10 = 2
 13 % 10 = 3
 14 % 10 = 4
 15 % 10 = 5
 16 % 10 = 6
 17 % 10 = 7
 18 % 10 = 8
 19 % 10 = 9
100 % 10 = 0
101 % 10 = 1
102 % 10 = 2
103 % 10 = 3
104 % 10 = 4
105 % 10 = 5
106 % 10 = 6
107 % 10 = 7
108 % 10 = 8
109 % 10 = 9
  2138 % 10 = 8
 65782 % 10 = 2
534196 % 10 = 6
10 の割り算の余りは、１の位がそのまま余りなので単純です。
ですが、割る値が 3 だろうと、7 だろうと、59 だろうと、2565 だろうと、余りの求め方は単純です。
   3 なら 0 ～ 2     です。
   7 なら 0 ～ 6     です。
  59 なら 0 ～ 58    です。
2565 なら 0 ～ 2564  です。
   n なら 0 ～ n - 1 です。
要するに余りは 0 ～ (割る値 - 1) の範囲です。
最後の x += 1 ですが、
x に 1 を足すと言う事は、乱数の範囲が 0 ～ でななく、1 ～ になると言う事です。
例えば、2565 の剰余は 0 ～ 2564 のいずれかの値ですが、
これに 1 を足すと言う事は、
(0 + 1) ～ (2564 + 1) なので、
1 ～ 2565 と言う事です。
要するにこの式の答えは 1 ～ 10 のいずれかの値と言う事です。
int x = rand() % 10 + 1;
例えば 0 ～ 9 の値が欲しいならこうなります。（何も足さなければいい）
int x = rand() % 10;
例えば 100 ～ 110 の値が欲しいならこうなります。（11 で割ると剰余は 0 ～ 10 。それに 100 を足したら 100 ～ 110 です）
int x = rand() % 11 + 100;
printf 命令を解説
printf("\x1b[3;%dH%c", x, c);
これを分解すると以下のようになります。２つの printf を１行で書いただけなんですね。
printf("\x1b[3;%dH", x);
printf("%c", c);
２行目の printf("%c", c); は単純に１文字を出力してるだけです。
分かり難いのは１行目です。この呪文は前に説明したコンソールの出力位置を指定するやつです。
"\x1b[3;%dH"
前に説明した時は、以下のように３行目の７桁目に出力すると言う風でした。
"\x1b[3;7H"
要するに 7 の位置を %d にしたわけです。
printf では %d の位置は、引数で渡した値に置き換えるので、x の値になるわけです。
x の値は 1 ～ 10 なので、そのいずれかになります。
だからキーボードを押すと３行目の１～１０桁のいずれかの位置に文字が出力されます。
《余談》
コンソールの出力位置をなぜ 1 からにしているのかと言うと、コンソールの出力位置の左端は 1 なんです。
プログラムでは珍しく 0 からではなく 1 からなんですよ。 （編集済み） 

なまはむ  21:17
文字と１０進数と１６進数で出力する
#include <stdio.h>
#include <conio.h>
int main()
{
	while (1) {
		if (_kbhit()) {
			int c = _getch();
			printf("\x1b[2J\x1b[1;1H%c %d %x", c, c, c);
		}
	}
	return 0;
}
結果
キーボードを押すとそのキーの文字と１０進数と１６進数で出力
printf 命令を分解して解説
printf("\x1b[2J\x1b[1;1H%c %d %x", c, c, c);
↓
printf("\x1b[2J");      // 出力をクリアする
printf("\x1b[1;1H");    // 出力位置を１行目の１桁目に移動する
printf("%c", c);        // 文字を出力
printf(" %d", c);       // １０進数で出力
printf(" %x", c);       // １６進数で出力（x は１６進数 hexadecimal の３つ目の文字の x です。なんで h じゃないねん！）
今回は特に詳しく説明する事が無いです。
あえて説明するなら前にちょこっと説明した出力をクリアする呪文くらいかな。
"\x1b[2J"
2J の 2 とか意味ありげですが、特に意味は無く、"\x1b[2J" が出力をクリアする呪文です。
《実験：エスケープキーを押す》
キーボードの左上にある ESC キーを押すと以下のように表示されます。
7 1b
ESC の文字は表示されません。ESC は文字じゃないからです。
このような文字を制御文字と言います。
《補足》
ESC の文字コードを１０進数で出力すると本来なら 27 が出力されるはずです。
ですが、先に文字として ESC を出力してしまったため、次の１０進数の出力に影響が出ています。
具体的にどうなってるかよくわからないのですが、27 の 2 が出力されないようです。（正確には 27 の前にあるはずの半角のｽﾍﾟｰｽも消えてます）
《余談》
１６進数の 1b ってどこかで見覚えがありますね。
printf("\x1b[2J");      // 出力をクリアする
printf("\x1b[1;1H");    // 出力位置を１行目の１桁目に移動する
呪文の中にある 1b の事です。
\x1b
の x は１６進数の意味の x です。
\x1b はエスケープコードと言い、コンソール制御用の呪文の事をエスケープシーケンスと言います。
《実験２：Enter や BackSpace 等も制御文字です》
文字コードは出力できますが、文字は出力されません。 （編集済み） 

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

文字を飛ばす

#include <stdio.h>
#include <conio.h>
#include <windows.h>
int main()
{
	while (1) {
		if (_kbhit()) {
			int c = _getch();
			for (int y = 20; y >= 1; y--) {
				printf("\x1b[2J\x1b[%d;10H%c", y, c);
				Sleep(10);
			}
		}
	}
	return 0;
}
結果
キーボードを押すとそのキーの文字が下から上に向かって飛ぶ

お休み命令の Sleep を使うためにインクルードする
#include <windows.h>

《Sleep の使い方》
・Sleep の最初の１文字目の S は大文字の S です。
・Sleep(ミリ秒) 指定の時間、何もせず待ちます。

ミリ秒は１秒の1000分の１の時間です。
要するに１秒は1000ミリ秒です。（１秒 = 1000ミリ秒）
Sleep(10);
10ミリ秒を指定すると、0.01秒の間、何もせずただ待つだけの処理を行います。

お休みを入れた理由は、処理が速過ぎて、文字が下から上に飛んでいくのが分かり難いからです。

余談：
この Sleep と言う命令は精度が悪く、最低でも指定された時間分はお休みしますが、
超過誤差が 10 ～ 20 ミリ秒くらいあります。
要するに Sleep(10) の場合、20 ～ 30 ミリ秒くらい休んじゃいます。
プログラムの練習なら気にするほどの誤差じゃないです。

《for 文の解説》
for (int y = 20; y >= 1; y--) {
	// （処理）
}
y の初期値を 20 にして、y が 1 以上の間ループします。
y の値はループするたびに y-- なので、1 ずつ減っていきます。
20 → 19 → 18 → 17 → … → 3 → 2 → 1
y >= 1 なので、1 の時も処理します。

《printf 命令を分解して解説》
printf("\x1b[2J\x1b[%d;10H%c", y, c);
↓
printf("\x1b[2J");           // 出力をクリアする
printf("\x1b[%d;10H", y);    // 出力位置を y 行目の 10 桁目に移動する
printf("%c", c);             // 文字を出力

出力のたびに、画面をクリアして、y の位置に文字を出力しているだけです。
y の値は 20 から 1 に減っていくので、文字が下から上に飛んでいくように見えます。

《実験：キーボードを連打する。５回くらい》
１回目の文字が上に着くまでに押したキーの分が遅れて飛んで行く事が確認できると思います。
これは、文字が上に上がっていく for 文を処理中に押されたキーが記憶されていると言う事です。

キーは押された順に記憶されていきます。
記憶されたキーは _getch() で記憶された順に１つ取り出す事ができます。
取り出されたキーは記憶から削除されます。

と言う事は、_getch() で取り出さない限り「キーは記憶され続けている」と言う事です。
この記憶領域の事をキーボードバッファと言います。
無制限に記憶できるわけではありませんが、かなりの量を記憶できます。

このキーボードバッファの存在は、良し悪しです。
記憶が残っていれば、処理が遅くてもキーを取りこぼす事が無いような処理が組めます。
逆に、今回のサンプルのように記憶されてる必要がない処理もあります。

《キーボードバッファのクリア》
残念ならが _getch() 用のキーボードバッファのクリア命令は存在しません。
次のように処理でクリアします。
while (_kbhit()) { _getch(); }
単純です。キーボードバッファが空になるまで取得するだけです。
以下のところにこのコードを追加すればキーボードバッファをクリアできます。
#include <stdio.h>
#include <conio.h>
#include <windows.h>
int main()
{
	while (1) {
		if (_kbhit()) {
			int c = _getch();
			for (int y = 20; y >= 1; y--) {
				printf("\x1b[2J\x1b[%d;10H%c", y, c);
				Sleep(10);
			}
			while (_kbhit()) { _getch(); }      // ★ここ！
		}
	}
	return 0;
}

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

文字を飛ばす２
#include <stdio.h>
#include <conio.h>
#include <windows.h>
int main()
{
	int y = 0;		// ★この初期化は必須です。
	int c;

	while (1) {

		// 文字を取得
		if (_kbhit()) {
			c = _getch();
			y = 20;
		}

		// 画面をクリア
		printf("\x1b[2J");

		// 文字を出力
		if (y > 0) {	// y が 0 より大きいなら
			printf("\x1b[%d;10H%c", y, c);
			y--;
		}

		// お休み
		Sleep(10);
	}
	return 0;
}
結果
キーボードを押すとそのキーの文字が下から上に向かって飛ぶ。
前との違いは、キーボードを連打するとすぐに次の文字が飛びます。

特に説明しなくても理解できるのではないでしょうか？

キーボードが押された時に文字を取得
if (_kbhit()) {
	c = _getch();
	y = 20;		// y に 20 を代入（★初期化式）
}

画面をクリア
printf("\x1b[2J");

文字を出力
if (y > 0) {	// y が 0 より大きいなら処理する（★条件式）
	printf("\x1b[%d;10H%c", y, c);
	y--;		// y の値をデクリメント（★後始末の式）
}

お休み
Sleep(10);

《★この初期化は必須です。》
int y = 0;		// ★この初期化は必須です。
この初期化が無いとプログラムがエラーで止まります。

以下のように書き換えて実行するとエラーになります。
int y;
エラーで止まった場合は Shift + F5 で実行の強制停止です。

なぜなのか？
変数は宣言しただけでは中に何が入ってるか分からないからです。
始めて変数に数値を代入する事を初期化と言います。
なので、以下のようにしてもちゃんと動きます。
int y;
y = 0;			// 始めて変数に数値を代入する事を初期化と言います。

初期化せずにエラーとなったは以下の箇所です。
if (y > 0) {	// y が 0 より大きいなら

プログラム実行直後は、y が初期化されずにここを通ります。
初期化されていない値を使おうとしたのでエラーになりました。

《余談》
昔はこんなエラーは教えてくれませんでした。
Visual Studio が進化しすぎて、このような予期せぬ問題すら教えてくれるようになりました。
昔なら y の値が不確定な事によって、実行する度にうまく動いたり、動かなかったりして、
その問題を見つけるのが大変でした。

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

文字を飛ばす３
#include <stdio.h>
#include <conio.h>
#include <windows.h>
int main()
{
	int f = 0;		// ★この初期化は必須

	int y0 = 0;		// ★この初期化は必須
	int y1 = 0;		// ★この初期化は必須
	int y2 = 0;		// ★この初期化は必須

	int c0, c1, c2;

	while (1) {

		// 文字を取得
		if (_kbhit()) {

			// f の値によって変数を使い分ける
			if (f == 0) {
				c0 = _getch();
				y0 = 20;
			}
			else if (f == 1) {
				c1 = _getch();
				y1 = 20;
			}
			else {	// f == 2
				c2 = _getch();
				y2 = 20;
			}

			// f の値を進める（0 1 2 0 1 2 0 1 2 …を繰り返します）
			f = (f + 1) % 3;
		}

		printf("\x1b[2J");	// 画面をクリア

		if (y0 > 0) {		// 文字を出力０
			printf("\x1b[%d;10H%c", y0, c0);
			y0--;
		}

		if (y1 > 0) {		// 文字を出力１
			printf("\x1b[%d;10H%c", y1, c1);
			y1--;
		}

		if (y2 > 0) {		// 文字を出力２
			printf("\x1b[%d;10H%c", y2, c2);
			y2--;
		}

		Sleep(50);			// お休み
	}

	return 0;
}
結果
キーボードを押すとそのキーの文字が下から上に向かって飛ぶ。
前との違いは、３つまで同時に文字が飛びます。
補足
このサンプルはとてもナンセンスなプログラムです。
同じ処理を３回も書いています。
あくまでも学習のためです。

複雑なようですが、やってる事は「文字を飛ばす２」と同じです。
ただし文字を３つ飛ばすために同じような処理が３回ずつあるだけです。

変数の定義が３回分（変数の名前の後ろに 0 1 2 と付けて各３個ずつ宣言しています）
int y = 0;		// ★この初期化は必須です。
int c;
↓
int y0 = 0;		// ★この初期化は必須
int y1 = 0;		// ★この初期化は必須
int y2 = 0;		// ★この初期化は必須
int c0, c1, c2;

キーボードが押された時の処理が３回分
c = _getch();
y = 20;
↓
c0 = _getch();
y0 = 20;

c1 = _getch();
y1 = 20;

c2 = _getch();
y2 = 20;

文字を飛ばす処理が３回分
if (y > 0) {	// y が 0 より大きいなら
	printf("\x1b[%d;10H%c", y, c);
	y--;
}
↓
if (y0 > 0) {		// 文字を出力０
	printf("\x1b[%d;10H%c", y0, c0);
	y0--;
}

if (y1 > 0) {		// 文字を出力１
	printf("\x1b[%d;10H%c", y1, c1);
	y1--;
}

if (y2 > 0) {		// 文字を出力２
	printf("\x1b[%d;10H%c", y2, c2);
	y2--;
}

説明が必要なのは以下の部分です
// f の値によって変数を使い分ける
if (f == 0) {
	c0 = _getch();
	y0 = 20;
}
else if (f == 1) {
	c1 = _getch();
	y1 = 20;
}
else {	// f == 2
	c2 = _getch();
	y2 = 20;
}

// f の値を進める（0 1 2 0 1 2 0 1 2 …を繰り返します）
f = (f + 1) % 3;

ソース中のコメント通りですが、f の値によって処理が分岐しています。

if 及び、else if と else と言う構文を組み合わせです。
if (f == 0) {		１．まず最初にこの if の条件が判定されます。
}
else if (f == 1) {	２．上の if の条件が成立しなかった場合、次にこの else if が判定されます。
}
else {				３．if と、else if の両方の条件が成立しなかった場合に処理されます。
}

else には条件式はありません。
if 及び else if のどちらも成立しなかった場合に処理されます。

else if はいくつでも追加できます。
if (f == 0) {		
}
else if (f == 0) {	★if と条件が同じ（無意味な処理）
}
else if (f == 1) {
}
else if (f == 2) {
}
else if (f == 3) {
}
else if (f == 3) {	★他の else if と条件が同じ（無意味な処理）
}
else if (f == 4) {
}
★ else はなくてもいい

★if と条件が同じ else if がありますが、
if の条件が先に成立するので、この else if を通る事はあり得ません。
無意味な処理です

★他の else if と条件が同じ else if がありますが、
前にある else if の条件が先に成立するので、この else if を通る事はあり得ません。
無意味な処理です

f の値を進める処理
f = (f + 1) % 3;	// f の値を進める（0 1 2 0 1 2 0 1 2 …を繰り返します）

3 の剰余を求めると言う事は、3 で割った時の余りです。
(0 + 1) = 1 % 3 = 1
(1 + 1) = 2 % 3 = 2
(2 + 1) = 3 % 3 = 0
(0 + 1) = 1 % 3 = 1
(1 + 1) = 2 % 3 = 2
(2 + 1) = 3 % 3 = 0
・
・
・

今回は if、 else if、 else の学習でした。

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
配列
int main()
{
	int y[3];	// y と言う名前で、確保数 3 の int 型配列を宣言

	y[0] = 0;
	y[1] = 0;
	y[2] = 0;
	y[3] = 0;	// ▲これはエラーです。
}
動きのある処理じゃないので、実行しなくていいです。
何をしてるか分かりますか？
前に少しだけ教えた配列を宣言して、0 を代入してしています。
	int y[3];	// y と言う名前で、確保数 3 の int 型配列を宣言
確保数が 3 と言う事は、添え字（配列番号）は [0] [1] [2] の３個です。
なので、[3] へのアクセスはエラーです。
	y[3] = 0;	// ▲これはエラーです。
配列の宣言時に初期化する
	int y[3] = {0, 0, 0};
配列を for で初期化する
	int y[3];
	for (int i = 0; i < 3; i++) {		// i の値は 0 1 2 です。i が 3 になるとループを抜ける。
		y[i] = 0;
	}

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
定義
#define		Y_COUNT			3
int main()
{
	int y[Y_COUNT];							// y と言う名前で、確保数 Y_COUNT の int 型配列を宣言
	for (int i = 0; i < Y_COUNT; i++) {		// i の値は 0 ～ Y_COUNT - 1 です。i が Y_COUNT になるとループを抜ける。
		y[i] = 0;
	}
}

Y_COUNT と言う名前の定義を宣言しました。
//			定義名			定義内容
#define		Y_COUNT			3
定義の名前：Y_COUNT
定義の内容：3

プログラムがコンパイルされる際、
　定義名　は　定義内容　に置き換えられます。
　Y_COUNT は　3　　　　 に置き換えられます。

要する最初のサンプルソースはコンパイル時に以下のように置き換えられます。
int main()
{
	int y[3];
	for (int i = 0; i < 3; i++) {
		y[i] = 0;
	}
}

定義の何がすごいかと言うと、定義内容を変更するだけで、それが関係する処理を全て書き換えられると言う事です。
例えば以下のように 3 を 100 書き換えただけで、100 の配列を宣言し、その配列全てを 0 に初期化できるわけです。
#define		Y_COUNT			100				// ここを 3 → 100 にしただけです
int main()
{
	int y[Y_COUNT];							// y と言う名前で、確保数 Y_COUNT の int 型配列を宣言
	for (int i = 0; i < Y_COUNT; i++) {		// i の値は 0 ～ Y_COUNT - 1 です。i が Y_COUNT になるとループを抜ける。
		y[i] = 0;
	}
}
このサンプルソースでは Y_COUNT を２ヵ所しか使っていないので、すごさが分からないかもですが、
書き換えなくてはならない場所が１０ヵ所あったらどうでしょう？
書き換えるだけでも大変ですが、たぶん書き換え忘れるところもあるでしょう。

プログラムがコンパイルされる際、定義名の Y_COUNT は 定義内容の 3 に置き換えられます。

